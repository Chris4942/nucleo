use crate::chars::case_fold::CASE_FOLDING_SIMPLE;
use crate::MatcherConfig;

//autogenerated by generate-ucd
#[allow(warnings)]
#[rustfmt::skip]
mod case_fold;
mod normalize;

pub trait Char: Copy + Eq + Ord + std::fmt::Debug {
    const ASCII: bool;
    fn char_class(self, config: &MatcherConfig) -> CharClass;
    fn char_class_and_normalize(self, config: &MatcherConfig) -> (Self, CharClass);
    fn normalize(self, config: &MatcherConfig) -> Self;
}

impl Char for u8 {
    const ASCII: bool = true;
    #[inline]
    fn char_class(self, config: &MatcherConfig) -> CharClass {
        let c = self;
        // using manual if conditions instead optimizes better
        if c >= b'a' && c <= b'z' {
            CharClass::Lower
        } else if c >= b'A' && c <= b'Z' {
            CharClass::Upper
        } else if c >= b'0' && c <= b'9' {
            CharClass::Number
        } else if c.is_ascii_whitespace() {
            CharClass::Whitespace
        } else if config.delimeter_chars.contains(&c) {
            CharClass::Delimiter
        } else {
            CharClass::NonWord
        }
    }

    #[inline(always)]
    fn char_class_and_normalize(self, config: &MatcherConfig) -> (Self, CharClass) {
        let char_class = self.char_class(config);
        let normalized = if config.ignore_case && char_class == CharClass::Upper {
            self + 32
        } else {
            self
        };
        (normalized, char_class)
    }

    #[inline(always)]
    fn normalize(self, config: &MatcherConfig) -> Self {
        if config.ignore_case && self >= b'A' && self <= b'Z' {
            self + 32
        } else {
            self
        }
    }
}
fn char_class_non_ascii(c: char) -> CharClass {
    if c.is_lowercase() {
        CharClass::Lower
    } else if c.is_uppercase() {
        CharClass::Upper
    } else if c.is_numeric() {
        CharClass::Number
    } else if c.is_alphabetic() {
        CharClass::Letter
    } else if c.is_whitespace() {
        CharClass::Whitespace
    } else {
        CharClass::NonWord
    }
}
impl Char for char {
    const ASCII: bool = false;
    #[inline(always)]
    fn char_class(self, config: &MatcherConfig) -> CharClass {
        if self.is_ascii() {
            return (self as u8).char_class(config);
        }
        char_class_non_ascii(self)
    }

    #[inline(always)]
    fn char_class_and_normalize(mut self, config: &MatcherConfig) -> (Self, CharClass) {
        if self.is_ascii() {
            let (c, class) = (self as u8).char_class_and_normalize(config);
            return (c as char, class);
        }
        let char_class = char_class_non_ascii(self);
        if char_class == CharClass::Upper {
            self = CASE_FOLDING_SIMPLE
                .binary_search_by_key(&self, |(upper, _)| *upper)
                .map_or(self, |idx| CASE_FOLDING_SIMPLE[idx].1)
        }
        if config.normalize {
            self = normalize::normalize(self);
        }
        (self, char_class)
    }

    #[inline(always)]
    fn normalize(mut self, config: &MatcherConfig) -> Self {
        if config.normalize {
            self = normalize::normalize(self);
        }
        to_lower_case(self)
    }
}

pub use normalize::normalize;

#[inline(always)]
pub fn to_lower_case(c: char) -> char {
    if c >= 'A' && c <= 'Z' {
        char::from_u32(c as u32 + 32).unwrap()
    } else if !c.is_ascii() {
        CASE_FOLDING_SIMPLE
            .binary_search_by_key(&c, |(upper, _)| *upper)
            .map_or(c, |idx| CASE_FOLDING_SIMPLE[idx].1)
    } else {
        c
    }
}

#[derive(Debug, Eq, PartialEq, PartialOrd, Ord, Copy, Clone, Hash)]
#[non_exhaustive]
pub enum CharClass {
    Whitespace,
    NonWord,
    Delimiter,
    Lower,
    Upper,
    Letter,
    Number,
}

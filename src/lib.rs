// sadly this doens't optmimzie well currently
#![allow(clippy::manual_range_contains)]

use std::alloc::Layout;
use std::cmp::max;

use memchr::{memchr, memchr2};
use normalize::normalize;

//autogenerated by generate-ucd
#[allow(warnings)]
#[rustfmt::skip]
mod case_fold;
mod config;
mod normalize;

pub use config::{CaseMatching, CharClass, MatcherConfig};

use crate::config::{
    BONUS_BOUNDARY, BONUS_CONSECUTIVE, BONUS_FIRST_CHAR_MULTIPLIER, PENALTY_GAP_EXTENSION,
    PENALTY_GAP_START, SCORE_MATCH,
};

const MAX_MATRIX_SIZE: usize = 75 * 1024; // 300KB
const MAX_HAYSTACK_LEN: usize = 8192; // 64KB

#[derive(Clone, Copy, PartialEq, Eq)]
struct MatrixCell {
    score: u16,
    consecutive_chars: u16,
}

#[derive(Clone, Copy, PartialEq, Eq)]
struct HaystackChar {
    char: char,
    bonus: u16,
}

pub struct Matcher {
    pub config: MatcherConfig,
    matrix: Box<[MatrixCell; MAX_MATRIX_SIZE]>,
    haystack: Box<[HaystackChar; MAX_HAYSTACK_LEN]>,
    // needle can be at most as long as the haystack
    first_needle_occurance: Box<[u16; MAX_HAYSTACK_LEN]>,
}

pub struct Query {
    needle_chars: Vec<char>,
    is_ascii: bool,
    ignore_case: bool,
}

impl Query {
    fn push(&mut self, needle: &str, normalize_: bool, smart_case: bool) {
        self.needle_chars.reserve(needle.len());
        self.needle_chars.extend(needle.chars().map(|mut c| {
            if !c.is_ascii() {
                self.is_ascii = false;
            }
            if smart_case {
                if c.is_uppercase() {
                    self.ignore_case = false;
                }
            } else if self.ignore_case {
                if self.is_ascii {
                    c = to_lower_case::<true>(c)
                } else {
                    c = to_lower_case::<false>(c)
                }
            }
            if normalize_ && !self.is_ascii {
                c = normalize(c);
            }
            c
        }))
    }
}

#[inline(always)]
fn find_ascii_ignore_case(c: u8, haystack: &[u8]) -> Option<usize> {
    if c >= b'a' || c <= b'z' {
        memchr2(c, c + 32, haystack)
    } else {
        memchr(c, haystack)
    }
}
/// Safety: T must be vaind if initalized with zeros
unsafe fn zeroed_array_on_heap<T: Copy, const LEN: usize>() -> Box<[T; LEN]> {
    let layout = Layout::new::<[T; LEN]>();
    let res = std::alloc::alloc_zeroed(layout);
    if res.is_null() {
        std::alloc::handle_alloc_error(layout)
    }
    Box::from_raw(res as _)
}

impl Matcher {
    pub fn new(config: MatcherConfig) -> Self {
        // Safety: all data allocated here is just integers/structs that contain
        // integers so zeroed values are legal
        unsafe {
            Self {
                config,
                matrix: zeroed_array_on_heap(),
                haystack: zeroed_array_on_heap(),
                first_needle_occurance: zeroed_array_on_heap(),
            }
        }
    }

    pub fn compile_query(&self, needle: &str) -> Query {
        let mut query = Query {
            needle_chars: Vec::new(),
            is_ascii: true,
            ignore_case: self.config.case_matching == CaseMatching::Ignore,
        };
        query.push(
            needle,
            self.config.normalize,
            self.config.case_matching == CaseMatching::Smart,
        );
        query
    }
    pub fn recompile_query(&self, query: &mut Query, needle: &str) {
        query.needle_chars.clear();
        query.is_ascii = false;
        query.ignore_case = self.config.case_matching == CaseMatching::Ignore;
        query.push(
            needle,
            self.config.normalize,
            self.config.case_matching == CaseMatching::Smart,
        );
    }
    pub fn append_query(&self, query: &mut Query, needle: &str) {
        query.push(
            needle,
            self.config.normalize,
            self.config.case_matching == CaseMatching::Smart,
        );
    }

    pub fn fuzzy_match(&mut self, query: &Query, mut haystack: &str) -> Option<u16> {
        if haystack.len() > u32::MAX as usize {
            haystack = &haystack[..u32::MAX as usize]
        }
        if self.config.use_v1 {
            if query.is_ascii && !self.config.normalize {
                self.fuzzy_matcher_v1::<false, true>(query, haystack, &mut Vec::new())
            } else {
                self.fuzzy_matcher_v1::<false, false>(query, haystack, &mut Vec::new())
            }
        } else if query.is_ascii && !self.config.normalize {
            self.fuzzy_matcher_v2::<false, true>(query, haystack, &mut Vec::new())
        } else {
            self.fuzzy_matcher_v2::<false, false>(query, haystack, &mut Vec::new())
        }
    }

    pub fn fuzzy_indicies(
        &mut self,
        query: &Query,
        mut haystack: &str,
        indicies: &mut Vec<u32>,
    ) -> Option<u16> {
        if haystack.len() > u32::MAX as usize {
            haystack = &haystack[..u32::MAX as usize]
        }
        if self.config.use_v1 {
            if query.is_ascii && !self.config.normalize {
                self.fuzzy_matcher_v1::<true, true>(query, haystack, indicies)
            } else {
                self.fuzzy_matcher_v1::<true, false>(query, haystack, indicies)
            }
        } else if query.is_ascii && !self.config.normalize {
            self.fuzzy_matcher_v2::<true, true>(query, haystack, indicies)
        } else {
            self.fuzzy_matcher_v2::<true, false>(query, haystack, indicies)
        }
    }

    #[inline(always)]
    fn normalize_char<const ASCII_ONLY: bool>(&self, ignore_case: bool, mut c: char) -> char {
        if ignore_case {
            c = to_lower_case::<ASCII_ONLY>(c)
        }
        if !ASCII_ONLY && self.config.normalize {
            c = normalize(c)
        }
        c
    }

    fn prefilter_ascii(&self, query: &Query, mut haystack: &[u8]) -> Option<(usize, usize)> {
        let needle = &query.needle_chars;
        if query.ignore_case {
            let first_idx = find_ascii_ignore_case(needle[0] as u8, haystack)?;
            let mut last_idx = first_idx + 1;
            haystack = &haystack[last_idx..];
            for &c in &needle[1..] {
                let idx = find_ascii_ignore_case(c as u8, haystack)? + 1;
                last_idx += idx;
                haystack = &haystack[idx..];
            }
            Some((first_idx, last_idx))
        } else {
            let first_idx = memchr(needle[0] as u8, haystack)?;
            let mut last_idx = first_idx + 1;
            haystack = &haystack[last_idx..];
            for &c in &needle[1..] {
                let idx = memchr(c as u8, haystack)? + 1;
                last_idx += idx;
                haystack = &haystack[idx..];
            }
            Some((first_idx, last_idx))
        }
    }

    fn prefilter_non_ascii(&self, query: &Query, haystack: &str) -> Option<(usize, usize)> {
        let needle_char = query.needle_chars[0];
        let mut text = haystack
            .char_indices()
            .map(|(i, c)| (i, self.normalize_char::<false>(query.ignore_case, c)));

        let (match_start, c) = text.find(|&(_, c)| c == needle_char)?;
        Some((match_start, match_start + c.len_utf8()))
    }

    fn prefilter(&self, query: &Query, haystack: &str) -> Option<(usize, usize)> {
        // quickly reject small matches
        if query.needle_chars.len() > haystack.len() {
            return None;
        }
        if query.is_ascii {
            self.prefilter_ascii(query, haystack.as_bytes())
        } else {
            self.prefilter_non_ascii(query, haystack)
        }
    }

    fn fuzzy_matcher_v1<const INDICIES: bool, const ASCII_ONLY: bool>(
        &mut self,
        query: &Query,
        haystack: &str,
        indicies: &mut Vec<u32>,
    ) -> Option<u16> {
        let (start, end) = self.prefilter(query, haystack)?;
        self.fuzzy_matcher_v1_with_prefilter::<INDICIES, ASCII_ONLY>(
            query, haystack, start, end, indicies,
        )
    }

    fn fuzzy_matcher_v1_with_prefilter<const INDICIES: bool, const ASCII_ONLY: bool>(
        &mut self,
        query: &Query,
        haystack: &str,
        mut start: usize,
        mut end: usize,
        indicies: &mut Vec<u32>,
    ) -> Option<u16> {
        let first_char_end = if ASCII_ONLY { start + 1 } else { end };
        if !ASCII_ONLY && query.needle_chars.len() != 1 {
            let mut needle_iter = query.needle_chars[1..].iter().copied();
            if let Some(mut needle_char) = needle_iter.next() {
                let haystack = haystack[first_char_end..]
                    .char_indices()
                    .rev()
                    .map(|(i, c)| (i, self.normalize_char::<false>(query.ignore_case, c)));
                for (i, c) in haystack {
                    if c == needle_char {
                        let Some(next_needle_char) = needle_iter.next() else {
                            end = i + c.len_utf8();
                            break;
                        };
                        needle_char = next_needle_char;
                    }
                }
            }
        }
        // very simple, just mimimize from the back
        let match_ = haystack[first_char_end..end]
            .char_indices()
            .rev()
            .map(|(i, c)| (i, self.normalize_char::<ASCII_ONLY>(query.ignore_case, c)));

        let mut needle_iter = query.needle_chars[..].iter().rev().copied();
        let mut needle_char = needle_iter.next().unwrap();
        for (i, c) in match_ {
            if c == needle_char {
                let Some(next_needle_char) = needle_iter.next() else {
                    start = i;
                    break;
                };
                needle_char = next_needle_char;
            }
        }
        Some(self.calculate_score::<INDICIES, ASCII_ONLY>(query, haystack, start, end, indicies))
    }

    fn calculate_score<const INDICIES: bool, const ASCII_ONLY: bool>(
        &mut self,
        query: &Query,
        text: &str,
        match_start: usize,
        match_end: usize,
        indicies: &mut Vec<u32>,
    ) -> u16 {
        if INDICIES {
            indicies.reserve(query.needle_chars.len());
        }
        let mut prev_class = text[..match_start]
            .chars()
            .next_back()
            .map(|c| self.config.char_class(c))
            .unwrap_or(self.config.inital_char_class);
        let mut needle_idx = 0;
        let mut score = 0u16;
        let mut in_gap = false;
        let mut consecutive = 0;
        let mut first_bonus = 0u16;
        for (i, mut c) in text[match_start..match_end].char_indices() {
            let class = self.config.char_class(c);
            if (ASCII_ONLY || class == CharClass::Upper) && query.ignore_case {
                c = to_lower_case::<ASCII_ONLY>(c);
            }
            if self.config.normalize && !ASCII_ONLY {
                c = normalize(c)
            }
            if c == query.needle_chars[needle_idx] {
                if INDICIES {
                    indicies.push(i as u32)
                }
                score += SCORE_MATCH;
                let mut bonus = self.config.bonus_for(prev_class, class);
                if consecutive == 0 {
                    first_bonus = bonus
                } else {
                    // Break consecutive chunk
                    if bonus > first_bonus {
                        if bonus >= BONUS_BOUNDARY {
                            first_bonus = bonus;
                        } else {
                            bonus = max(bonus, BONUS_CONSECUTIVE);
                        }
                    } else {
                        bonus = max(first_bonus, BONUS_CONSECUTIVE);
                    }
                }
                if needle_idx == 0 {
                    bonus *= BONUS_FIRST_CHAR_MULTIPLIER;
                }
                score += bonus;
                needle_idx += 1;
                in_gap = false;
                consecutive += 1;
            } else {
                let penalty = if in_gap {
                    PENALTY_GAP_EXTENSION
                } else {
                    PENALTY_GAP_START
                };
                score = score.saturating_sub(penalty);
                in_gap = true;
                consecutive = 0;
                first_bonus = 0;
            }
            prev_class = class;
        }

        score
    }

    fn fuzzy_matcher_v2<const INDICIES: bool, const ASCII_ONLY: bool>(
        &mut self,
        query: &Query,
        text: &str,
        indicies: &mut Vec<u32>,
    ) -> Option<u16> {
        let (start, prefilter_end) = self.prefilter(query, text)?;
        let text_len = text.len() - start;
        // fallback to v1 algorithms for long haystacks
        // technically we need to multiply by char len here
        // but counting chars has a lot of unecessary overhead that we can avoid
        // here in practice using bytelen should be a reasonable approximation
        // we also differ from fzf here in that we never allocate and instead stringintly check here
        if text_len > u16::MAX as usize || text_len * query.needle_chars.len() > MAX_HAYSTACK_LEN {
            return self.fuzzy_matcher_v1_with_prefilter::<INDICIES, ASCII_ONLY>(
                query,
                text,
                start,
                prefilter_end,
                indicies,
            );
        }

        let mut prev_class = text[..start]
            .chars()
            .next_back()
            .map(|c| self.config.char_class(c))
            .unwrap_or(self.config.inital_char_class);

        let text = &text[start..];

        let mut needle_iter = query.needle_chars[..]
            .iter()
            .copied()
            .zip(self.first_needle_occurance.iter_mut());
        let (mut needle_char, mut needle_char_idx) = needle_iter.next().unwrap();

        let iter = text[start..]
            .chars()
            .zip(self.matrix.iter_mut())
            .zip(self.haystack.iter_mut())
            .enumerate();

        let mut last_matched_idx = 0;
        let mut max_score = 0;
        let mut max_score_pos = 0;
        let mut in_gap = false;
        let mut prev_score = 0u16;
        let mut matched = false;

        let first_needle_char = query.needle_chars[0];
        for (i, ((mut c, matrix_cell), char_info)) in iter {
            let class = self.config.char_class(c);
            if (ASCII_ONLY || class == CharClass::Upper) && query.ignore_case {
                c = to_lower_case::<ASCII_ONLY>(c);
            }
            if self.config.normalize && !ASCII_ONLY {
                c = normalize(c)
            }
            char_info.char = c;
            let bonus = self.config.bonus_for(prev_class, class);
            char_info.char = c;
            prev_class = class;

            let i = i as u16;
            if c == needle_char {
                // save the first idx of each char
                if let Some(next) = needle_iter.next() {
                    *needle_char_idx = i;
                    (needle_char, needle_char_idx) = next
                } else {
                    // we have atleast one match
                    matched = true;
                }
                // and the last matched char
                last_matched_idx = i;
            }
            if c == first_needle_char {
                let score = SCORE_MATCH + bonus * BONUS_FIRST_CHAR_MULTIPLIER;
                matrix_cell.consecutive_chars = 1;
                if query.needle_chars.len() == 1 && score > max_score {
                    max_score = score;
                    max_score_pos = i;
                    // can't get better than this
                    if bonus >= BONUS_BOUNDARY {
                        break;
                    }
                }
                in_gap = false;
            } else {
                let gap_penalty = if in_gap {
                    PENALTY_GAP_EXTENSION
                } else {
                    PENALTY_GAP_START
                };
                matrix_cell.score = prev_score.saturating_sub(gap_penalty);
                matrix_cell.consecutive_chars = 0;
                in_gap = true;
            }
            prev_score = matrix_cell.score;
        }
        if !matched {
            debug_assert!(!ASCII_ONLY, "prefilter should have rejected");
            return None;
        }
        if query.needle_chars.len() == 1 {
            indicies.push(max_score_pos as u32);
            return Some(max_score);
        }
        assert_eq!(
            self.first_needle_occurance[0], 0,
            "prefilter should have put us at the start of the match"
        );
        let haystack_len = last_matched_idx as usize + 1;
        let (max_score, best_match_end) = self.popultate_matrix(haystack_len, query);
        if INDICIES {
            indicies.reserve(query.needle_chars.len());
            let mut col = best_match_end;
            let mut needle_iter = self.matrix[..haystack_len * query.needle_chars.len()]
                .windows(haystack_len)
                .zip(self.first_needle_occurance[..haystack_len].iter())
                .rev()
                .peekable();
            let mut next_row = None;
            let (mut row, mut first_needle_occurance) = needle_iter.next().unwrap();
            let mut prefer_match = true;
            loop {
                let score = row[col as usize].score;
                let mut score1 = 0;
                let mut score2 = 0;
                if let Some((prev_row, _)) = needle_iter.peek() {
                    if col >= *first_needle_occurance {
                        score1 = prev_row[col as usize].score;
                    }
                }
                if col > *first_needle_occurance {
                    score2 = row[col as usize - 1].score;
                }
                if score > score1 && (score > score2 || score == score2 && prefer_match) {
                    indicies.push(col as u32 + start as u32);
                    next_row = Some(row);
                    let Some(next) = needle_iter.next() else {
                        break;
                    };
                    (row, first_needle_occurance) = next
                }
                prefer_match = row[col as usize].consecutive_chars > 1;
                if !prefer_match && col + 1 < query.needle_chars.len() as u16 {
                    if let Some(next_row) = next_row {
                        prefer_match = next_row[col as usize + 1].consecutive_chars > 0
                    }
                }
                col -= 1;
            }
        }

        Some(max_score)
    }

    fn popultate_matrix(&mut self, haystack_len: usize, query: &Query) -> (u16, u16) {
        let mut max_score = 0;
        let mut max_score_end = 0;
        let mut iter = query
            .needle_chars
            .iter()
            .zip(self.first_needle_occurance.iter())
            .zip(self.matrix.chunks_mut(haystack_len))
            .enumerate();
        // skip the first row we already calculated the initial scores
        let (_, ((&_, &_), mut prev_matrix_row)) = iter.next().unwrap();
        for (i, ((&needle_char, &first_occurance), matrix_row)) in iter {
            // help the optimizer out a little
            assert!((first_occurance as usize) < matrix_row.len());
            assert!(first_occurance != 0);
            let mut in_gap = false;
            let haystack = &self.haystack[first_occurance as usize..haystack_len];
            let mut prev_matrix_cell = matrix_row[first_occurance as usize - 1];
            let matrix_row = &mut matrix_row[first_occurance as usize..haystack_len];
            let prev_matrix_diagonal =
                &mut prev_matrix_row[first_occurance as usize - 1..haystack_len - 1];
            for (j, ((&haystack_char, matrix_cell), &diag_matrix_cell)) in haystack
                .iter()
                .zip(matrix_row.iter_mut())
                .zip(prev_matrix_diagonal.iter())
                .enumerate()
            {
                let col = j + first_occurance as usize;
                let gap_penalty = if in_gap {
                    PENALTY_GAP_EXTENSION
                } else {
                    PENALTY_GAP_START
                };
                let mut score1 = 0;
                let score2 = prev_matrix_cell.score.saturating_sub(gap_penalty);
                let mut consecutive = 0;
                if haystack_char.char == needle_char {
                    score1 = diag_matrix_cell.score + SCORE_MATCH;
                    let mut bonus = haystack_char.bonus;
                    consecutive = diag_matrix_cell.consecutive_chars + 1;
                    if consecutive > 1 {
                        let first_bonus = self.haystack[col - consecutive as usize].bonus;
                        if bonus > first_bonus {
                            if bonus > BONUS_BOUNDARY {
                                consecutive = 1
                            } else {
                                bonus = max(bonus, BONUS_CONSECUTIVE)
                            }
                        } else {
                            bonus = max(first_bonus, BONUS_CONSECUTIVE)
                        }
                    }
                    if score1 + bonus < score2 {
                        score1 += haystack_char.bonus;
                        consecutive = 0;
                    } else {
                        score1 += bonus;
                    }
                }
                in_gap = score1 < score2;
                let score = max(max(score1, score2), 0);
                prev_matrix_cell = *matrix_cell;
                if i == query.needle_chars.len() - 1 && score > max_score {
                    max_score = score;
                    max_score_end = col as u16;
                }
                matrix_cell.consecutive_chars = consecutive;
                matrix_cell.score = score;
            }
            prev_matrix_row = matrix_row;
        }
        (max_score, max_score_end)
    }
}

#[inline(always)]
fn to_lower_case<const ASCII_ONLY: bool>(c: char) -> char {
    if c >= 'A' && c <= 'Z' {
        char::from_u32(c as u32 + 32).unwrap()
    } else if !c.is_ascii() && !ASCII_ONLY {
        case_fold::CASE_FOLDING_SIMPLE
            .binary_search_by_key(&c, |(upper, _)| *upper)
            .map_or(c, |idx| case_fold::CASE_FOLDING_SIMPLE[idx].1)
    } else {
        c
    }
}
